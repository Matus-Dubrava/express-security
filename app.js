// securing app agains Cross-site request forgery attack (CSRF)
// can be achieved by including CSRF token in form, using hidden element
// with unique value generated by server to check wheter the
// form was generated by server or it was forged by someone else

// install "csurf"
npm install csurf

// load it in aplication
const csrf = requires('csurf');

// we can then use it as a middleware

// if we are using some form of session then it has to be
// placed after the session code and before any router which uses this
// kind of protection

// note that this way we are requiring csrf globaly (for every form)
// which means that every form needs to include csrf token, otherwise
// verification of that form will fail with message that csrf token is invalid
app.use(csrt());

// then in the form we need to pass this unque value to view which
// is responsible for rendering the form
const router = require('express').Router();

router.get('/form', (req, res) => {
  res.render('myView', {
    csrfToken: req.csrfToken()
  });
});

// finally we need to include it in form (ehre we are using ejs templating language),
// using hidden input with specific "name" attribute set to "_csrf"
<form action="/form" method="POST">
  <input type="hidden" value="<%= csrfToken %>" name="_csrf">
  ...
</form>

// server now generates unique value that is send to each form when that form
// is requested and verifies that if the value that it received upon form
// submittion is the same as the one it sent to the client

// if those two values mismatch or that value is missing when server receives
// post response then the request is considered as request forgery
// and fails to pass

// note that this security meassure is not enough to prevent attacker from
// stealing someone's session completely, if the attacker asks server
// to generate form form him, includes this form on his web site and
// somehow tricks user (clickbait attack) to clicking on the submit button
// then csrf verification passes since the form was generated by the server
// with valid csrf token and attacked is not modifying this value, therefore
// upon form submittion, server receives valid csrf token back

// to prevent this kind of attack (clickbait atack), we need to disallow
// anyone from including our website in theirs, which can be achieved by
// setting "X-Frame-Options" HTTP header to either DENY (which disallows anyone,
// including our site from including our page in a frame, iframe or object)
// or SAMEORIGIN (which is the same as before but we are allowed to include
// our site in, well... our site), there is also a third option, ALLOW-FROM http://...
// which white lists web sites that are allowed to include our site

// it is always a good idea to set X-Frame-Options to DENY if we don't have
// a strong reason not to

// note that we are responsible for including X-Frame-Options in response generated
// by our server but it is client's broweser that is responsible for enforcing this
// policy, so if for some reason it fails to do that (client's browser might be
// outdated and not recognize this header) then attacer will still be able to
// perform this kind of attack

// we can use module called frameguard to easyly set this header
npm install frameguard

// load frameguard module into our application
const frameguard = require('frameguard');

app.use(frameguard({ action: 'deny' }));

// ------------------------------------------------------------------

// Another issue may arise when someone uploads a text file to your server which
// may contain not a plain text but a malicious code, let's say executable
// javascript that.

// Later when server is asked to retrieve this file, it sends it as a plain text
// but browser may try to sniff its content and decides that it acutally is a
// valid JavaScript code and it might get executed, which is definitelly not
// desired behaviour from our standpoint

// to prevet this from happening, we can use another HTTP header called
// X-Content-Type-Options and set its value to "no-sniff"

// in our express application, this can be achieved simply by using "helmet"
// module

npm install helmet

const helmet = require('helmet');

app.use(helmet.noSniff());
